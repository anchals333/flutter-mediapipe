// Autogenerated from Pigeon (v10.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

/// A classification category.
/// Category is a util class, contains a label, its display name, a float
/// value as score, and the index of the label in the corresponding label file.
/// Typically it's used as the result of classification tasks.
class Category {
  Category({
    this.index,
    this.score,
    this.displayName,
    this.categoryName,
  });

  /// The index of the label in the corresponding label file.
  int? index;

  /// The probability score of this label category.
  double? score;

  /// The display name of the label, which may be translated for
  /// different locales. For example, a label, "apple", may be translated into
  String? displayName;

  /// The label of this category object.
  String? categoryName;

  Object encode() {
    return <Object?>[
      index,
      score,
      displayName,
      categoryName,
    ];
  }

  static Category decode(Object result) {
    result as List<Object?>;
    return Category(
      index: result[0] as int?,
      score: result[1] as double?,
      displayName: result[2] as String?,
      categoryName: result[3] as String?,
    );
  }
}

/// Represents the list of classification for a given classifier head.
/// Typically used as a result for classification tasks.
class Classifications {
  Classifications({
    required this.categories,
    required this.headIndex,
    this.headName,
  });

  /// The array of predicted categories, usually sorted by descending
  /// scores (e.g. from high to low probability).
  List<Category?> categories;

  /// The index of the classifier head these categories refer to. This
  /// is useful for multi-head models.
  int headIndex;

  /// The name of the classifier head, which is the corresponding
  /// tensor metadata name.
  String? headName;

  Object encode() {
    return <Object?>[
      categories,
      headIndex,
      headName,
    ];
  }

  static Classifications decode(Object result) {
    result as List<Object?>;
    return Classifications(
      categories: (result[0] as List<Object?>?)!.cast<Category?>(),
      headIndex: result[1]! as int,
      headName: result[2] as String?,
    );
  }
}

/// Data returned from MediaPipe SDK.
class ClassificationResult {
  ClassificationResult({
    required this.classifications,
    this.timestampMs,
  });

  /// The classification results for each head of the model.
  List<Classifications?> classifications;

  /// The optional timestamp (in milliseconds) of the start of the chunk of
  /// data corresponding to these results.
  double? timestampMs;

  Object encode() {
    return <Object?>[
      classifications,
      timestampMs,
    ];
  }

  static ClassificationResult decode(Object result) {
    result as List<Object?>;
    return ClassificationResult(
      classifications: (result[0] as List<Object?>?)!.cast<Classifications?>(),
      timestampMs: result[1] as double?,
    );
  }
}

class _TextClassifierCodec extends StandardMessageCodec {
  const _TextClassifierCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is Category) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is ClassificationResult) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is Classifications) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return Category.decode(readValue(buffer)!);
      case 129: 
        return ClassificationResult.decode(readValue(buffer)!);
      case 130: 
        return Classifications.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class TextClassifier {
  /// Constructor for [TextClassifier].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  TextClassifier({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _TextClassifierCodec();

  Future<ClassificationResult> classify(String arg_value) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.TextClassifier.classify', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_value]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as ClassificationResult?)!;
    }
  }
}
